package data

// Code generated by gen.py. DO NOT EDIT.

import (
	"reflect"

	"github.com/apache/arrow/go/arrow"
	"github.com/apache/arrow/go/arrow/array"
	"github.com/apache/arrow/go/arrow/memory"
	"github.com/pkg/errors"
)

// Series implemented on the top of Apache Arrow.

// newArrowSeriesFromSlice converts a slice of scalars to a new (Arrow-based) Series.
// notNull denotes elements set to null; it is optional and can be set to nil.
// Only a closed list of primitive data types is supported.
func newArrowSeriesFromSlice(col ColumnName, values interface{}, notNull []bool) (*Series, error) {
	switch typedValues := values.(type) {
	case []float64:
		return newArrowSeriesFromSliceFloat64(col, typedValues, notNull), nil
	case []int64:
		return newArrowSeriesFromSliceInt64(col, typedValues, notNull), nil
	case []string:
		return newArrowSeriesFromSliceString(col, typedValues, notNull), nil
	case []bool:
		return newArrowSeriesFromSliceBool(col, typedValues, notNull), nil
	case []TimestampMillis:
		return newArrowSeriesFromSliceTimestampMillis(col, typedValues, notNull), nil
	case []TimestampMicros:
		return newArrowSeriesFromSliceTimestampMicros(col, typedValues, notNull), nil
	default:
		return nil, errors.Errorf("The data type %v is not supported, expecting slice of supported primitive types", reflect.TypeOf(values))
	}
}

// float64

type arrowSeriesBuilderFloat64 struct {
	builder *array.Float64Builder
	column  Column
}

func newArrowSeriesBuilderFloat64(col ColumnName) *arrowSeriesBuilderFloat64 {
	return &arrowSeriesBuilderFloat64{
		builder: array.NewFloat64Builder(memory.DefaultAllocator),
		column: Column{
			Name: col,
			Type: typeFloat64,
		},
	}
}

func (b *arrowSeriesBuilderFloat64) Column() Column       { return b.column }
func (b *arrowSeriesBuilderFloat64) Reserve(capacity int) { b.builder.Reserve(capacity) }
func (b *arrowSeriesBuilderFloat64) Size() int            { return b.builder.Len() }

func (b *arrowSeriesBuilderFloat64) Append(value interface{}) {
	if value == nil {
		b.builder.AppendNull()
		return
	}

	typedValue := value.(float64)
	b.builder.Append(typedValue)
}

func (b *arrowSeriesBuilderFloat64) AppendFloat64(value float64, notNull bool) {
	if !notNull {
		b.builder.AppendNull()
		return
	}
	b.builder.Append(value)
}

func (b *arrowSeriesBuilderFloat64) Build() *Series {
	metadata := &arrowSeriesMeta{values: b.builder.NewFloat64Array()}
	return &Series{
		typ:  typeFloat64,
		col:  b.column.Name,
		read: metadata.readFloat64,
		meta: metadata,
	}
}

var _ seriesBuilderFloat64 = (*arrowSeriesBuilderFloat64)(nil)

func newArrowSeriesFromSliceFloat64(col ColumnName, values []float64, mask []bool) *Series {
	builder := newArrowSeriesBuilderFloat64(col)
	builder.Reserve(len(values))

	for i := range values {
		builder.AppendFloat64(values[i], mask == nil || mask[i])
	}

	return builder.Build()
}

func (m *arrowSeriesMeta) readFloat64(_ *seriesIterCache) iterator {
	return &arrowSeriesIterFloat64{
		values: m.values.(*array.Float64),
		pos:    -1,
	}
}

type arrowSeriesIterFloat64 struct {
	values *array.Float64
	pos    int
}

func (i *arrowSeriesIterFloat64) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *arrowSeriesIterFloat64) Float64() (float64, bool) {
	if !i.values.IsNull(i.pos) {
		return i.values.Value(i.pos), true
	} else {
		return float64(0), false
	}
}

func (i *arrowSeriesIterFloat64) Value() interface{} {
	if val, ok := i.Float64(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*arrowSeriesIterFloat64)(nil)
var _ iterFloat64 = (*arrowSeriesIterFloat64)(nil)

// int64

type arrowSeriesBuilderInt64 struct {
	builder *array.Int64Builder
	column  Column
}

func newArrowSeriesBuilderInt64(col ColumnName) *arrowSeriesBuilderInt64 {
	return &arrowSeriesBuilderInt64{
		builder: array.NewInt64Builder(memory.DefaultAllocator),
		column: Column{
			Name: col,
			Type: typeInt64,
		},
	}
}

func (b *arrowSeriesBuilderInt64) Column() Column       { return b.column }
func (b *arrowSeriesBuilderInt64) Reserve(capacity int) { b.builder.Reserve(capacity) }
func (b *arrowSeriesBuilderInt64) Size() int            { return b.builder.Len() }

func (b *arrowSeriesBuilderInt64) Append(value interface{}) {
	if value == nil {
		b.builder.AppendNull()
		return
	}

	typedValue := value.(int64)
	b.builder.Append(typedValue)
}

func (b *arrowSeriesBuilderInt64) AppendInt64(value int64, notNull bool) {
	if !notNull {
		b.builder.AppendNull()
		return
	}
	b.builder.Append(value)
}

func (b *arrowSeriesBuilderInt64) Build() *Series {
	metadata := &arrowSeriesMeta{values: b.builder.NewInt64Array()}
	return &Series{
		typ:  typeInt64,
		col:  b.column.Name,
		read: metadata.readInt64,
		meta: metadata,
	}
}

var _ seriesBuilderInt64 = (*arrowSeriesBuilderInt64)(nil)

func newArrowSeriesFromSliceInt64(col ColumnName, values []int64, mask []bool) *Series {
	builder := newArrowSeriesBuilderInt64(col)
	builder.Reserve(len(values))

	for i := range values {
		builder.AppendInt64(values[i], mask == nil || mask[i])
	}

	return builder.Build()
}

func (m *arrowSeriesMeta) readInt64(_ *seriesIterCache) iterator {
	return &arrowSeriesIterInt64{
		values: m.values.(*array.Int64),
		pos:    -1,
	}
}

type arrowSeriesIterInt64 struct {
	values *array.Int64
	pos    int
}

func (i *arrowSeriesIterInt64) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *arrowSeriesIterInt64) Int64() (int64, bool) {
	if !i.values.IsNull(i.pos) {
		return i.values.Value(i.pos), true
	} else {
		return int64(0), false
	}
}

func (i *arrowSeriesIterInt64) Value() interface{} {
	if val, ok := i.Int64(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*arrowSeriesIterInt64)(nil)
var _ iterInt64 = (*arrowSeriesIterInt64)(nil)

// string

type arrowSeriesBuilderString struct {
	builder *array.StringBuilder
	column  Column
}

func newArrowSeriesBuilderString(col ColumnName) *arrowSeriesBuilderString {
	return &arrowSeriesBuilderString{
		builder: array.NewStringBuilder(memory.DefaultAllocator),
		column: Column{
			Name: col,
			Type: typeString,
		},
	}
}

func (b *arrowSeriesBuilderString) Column() Column       { return b.column }
func (b *arrowSeriesBuilderString) Reserve(capacity int) { b.builder.Reserve(capacity) }
func (b *arrowSeriesBuilderString) Size() int            { return b.builder.Len() }

func (b *arrowSeriesBuilderString) Append(value interface{}) {
	if value == nil {
		b.builder.AppendNull()
		return
	}

	typedValue := value.(string)
	b.builder.Append(typedValue)
}

func (b *arrowSeriesBuilderString) AppendString(value string, notNull bool) {
	if !notNull {
		b.builder.AppendNull()
		return
	}
	b.builder.Append(value)
}

func (b *arrowSeriesBuilderString) Build() *Series {
	metadata := &arrowSeriesMeta{values: b.builder.NewStringArray()}
	return &Series{
		typ:  typeString,
		col:  b.column.Name,
		read: metadata.readString,
		meta: metadata,
	}
}

var _ seriesBuilderString = (*arrowSeriesBuilderString)(nil)

func newArrowSeriesFromSliceString(col ColumnName, values []string, mask []bool) *Series {
	builder := newArrowSeriesBuilderString(col)
	builder.Reserve(len(values))

	for i := range values {
		builder.AppendString(values[i], mask == nil || mask[i])
	}

	return builder.Build()
}

func (m *arrowSeriesMeta) readString(_ *seriesIterCache) iterator {
	return &arrowSeriesIterString{
		values: m.values.(*array.String),
		pos:    -1,
	}
}

type arrowSeriesIterString struct {
	values *array.String
	pos    int
}

func (i *arrowSeriesIterString) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *arrowSeriesIterString) String() (string, bool) {
	if !i.values.IsNull(i.pos) {
		return i.values.Value(i.pos), true
	} else {
		return "", false
	}
}

func (i *arrowSeriesIterString) Value() interface{} {
	if val, ok := i.String(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*arrowSeriesIterString)(nil)
var _ iterString = (*arrowSeriesIterString)(nil)

// bool

type arrowSeriesBuilderBool struct {
	builder *array.BooleanBuilder
	column  Column
}

func newArrowSeriesBuilderBool(col ColumnName) *arrowSeriesBuilderBool {
	return &arrowSeriesBuilderBool{
		builder: array.NewBooleanBuilder(memory.DefaultAllocator),
		column: Column{
			Name: col,
			Type: typeBool,
		},
	}
}

func (b *arrowSeriesBuilderBool) Column() Column       { return b.column }
func (b *arrowSeriesBuilderBool) Reserve(capacity int) { b.builder.Reserve(capacity) }
func (b *arrowSeriesBuilderBool) Size() int            { return b.builder.Len() }

func (b *arrowSeriesBuilderBool) Append(value interface{}) {
	if value == nil {
		b.builder.AppendNull()
		return
	}

	typedValue := value.(bool)
	b.builder.Append(typedValue)
}

func (b *arrowSeriesBuilderBool) AppendBool(value bool, notNull bool) {
	if !notNull {
		b.builder.AppendNull()
		return
	}
	b.builder.Append(value)
}

func (b *arrowSeriesBuilderBool) Build() *Series {
	metadata := &arrowSeriesMeta{values: b.builder.NewBooleanArray()}
	return &Series{
		typ:  typeBool,
		col:  b.column.Name,
		read: metadata.readBool,
		meta: metadata,
	}
}

var _ seriesBuilderBool = (*arrowSeriesBuilderBool)(nil)

func newArrowSeriesFromSliceBool(col ColumnName, values []bool, mask []bool) *Series {
	builder := newArrowSeriesBuilderBool(col)
	builder.Reserve(len(values))

	for i := range values {
		builder.AppendBool(values[i], mask == nil || mask[i])
	}

	return builder.Build()
}

func (m *arrowSeriesMeta) readBool(_ *seriesIterCache) iterator {
	return &arrowSeriesIterBool{
		values: m.values.(*array.Boolean),
		pos:    -1,
	}
}

type arrowSeriesIterBool struct {
	values *array.Boolean
	pos    int
}

func (i *arrowSeriesIterBool) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *arrowSeriesIterBool) Bool() (bool, bool) {
	if !i.values.IsNull(i.pos) {
		return i.values.Value(i.pos), true
	} else {
		return false, false
	}
}

func (i *arrowSeriesIterBool) Value() interface{} {
	if val, ok := i.Bool(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*arrowSeriesIterBool)(nil)
var _ iterBool = (*arrowSeriesIterBool)(nil)

// TimestampMillis

type arrowSeriesBuilderTimestampMillis struct {
	builder *array.TimestampBuilder
	column  Column
}

func newArrowSeriesBuilderTimestampMillis(col ColumnName) *arrowSeriesBuilderTimestampMillis {
	return &arrowSeriesBuilderTimestampMillis{
		builder: array.NewTimestampBuilder(memory.DefaultAllocator, &arrow.TimestampType{Unit: arrow.Millisecond}),
		column: Column{
			Name: col,
			Type: typeTimestampMillis,
		},
	}
}

func (b *arrowSeriesBuilderTimestampMillis) Column() Column       { return b.column }
func (b *arrowSeriesBuilderTimestampMillis) Reserve(capacity int) { b.builder.Reserve(capacity) }
func (b *arrowSeriesBuilderTimestampMillis) Size() int            { return b.builder.Len() }

func (b *arrowSeriesBuilderTimestampMillis) Append(value interface{}) {
	if value == nil {
		b.builder.AppendNull()
		return
	}

	typedValue := value.(TimestampMillis)
	b.builder.Append(arrow.Timestamp(typedValue))
}

func (b *arrowSeriesBuilderTimestampMillis) AppendTimestampMillis(value TimestampMillis, notNull bool) {
	if !notNull {
		b.builder.AppendNull()
		return
	}
	b.builder.Append(arrow.Timestamp(value))
}

func (b *arrowSeriesBuilderTimestampMillis) Build() *Series {
	metadata := &arrowSeriesMeta{values: b.builder.NewTimestampArray()}
	return &Series{
		typ:  typeTimestampMillis,
		col:  b.column.Name,
		read: metadata.readTimestampMillis,
		meta: metadata,
	}
}

var _ seriesBuilderTimestampMillis = (*arrowSeriesBuilderTimestampMillis)(nil)

func newArrowSeriesFromSliceTimestampMillis(col ColumnName, values []TimestampMillis, mask []bool) *Series {
	builder := newArrowSeriesBuilderTimestampMillis(col)
	builder.Reserve(len(values))

	for i := range values {
		builder.AppendTimestampMillis(values[i], mask == nil || mask[i])
	}

	return builder.Build()
}

func (m *arrowSeriesMeta) readTimestampMillis(_ *seriesIterCache) iterator {
	return &arrowSeriesIterTimestampMillis{
		values: m.values.(*array.Timestamp),
		pos:    -1,
	}
}

type arrowSeriesIterTimestampMillis struct {
	values *array.Timestamp
	pos    int
}

func (i *arrowSeriesIterTimestampMillis) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *arrowSeriesIterTimestampMillis) TimestampMillis() (TimestampMillis, bool) {
	if !i.values.IsNull(i.pos) {
		return TimestampMillis(i.values.Value(i.pos)), true
	} else {
		return TimestampMillis(0), false
	}
}

func (i *arrowSeriesIterTimestampMillis) Value() interface{} {
	if val, ok := i.TimestampMillis(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*arrowSeriesIterTimestampMillis)(nil)
var _ iterTimestampMillis = (*arrowSeriesIterTimestampMillis)(nil)

// TimestampMicros

type arrowSeriesBuilderTimestampMicros struct {
	builder *array.TimestampBuilder
	column  Column
}

func newArrowSeriesBuilderTimestampMicros(col ColumnName) *arrowSeriesBuilderTimestampMicros {
	return &arrowSeriesBuilderTimestampMicros{
		builder: array.NewTimestampBuilder(memory.DefaultAllocator, &arrow.TimestampType{Unit: arrow.Microsecond}),
		column: Column{
			Name: col,
			Type: typeTimestampMicros,
		},
	}
}

func (b *arrowSeriesBuilderTimestampMicros) Column() Column       { return b.column }
func (b *arrowSeriesBuilderTimestampMicros) Reserve(capacity int) { b.builder.Reserve(capacity) }
func (b *arrowSeriesBuilderTimestampMicros) Size() int            { return b.builder.Len() }

func (b *arrowSeriesBuilderTimestampMicros) Append(value interface{}) {
	if value == nil {
		b.builder.AppendNull()
		return
	}

	typedValue := value.(TimestampMicros)
	b.builder.Append(arrow.Timestamp(typedValue))
}

func (b *arrowSeriesBuilderTimestampMicros) AppendTimestampMicros(value TimestampMicros, notNull bool) {
	if !notNull {
		b.builder.AppendNull()
		return
	}
	b.builder.Append(arrow.Timestamp(value))
}

func (b *arrowSeriesBuilderTimestampMicros) Build() *Series {
	metadata := &arrowSeriesMeta{values: b.builder.NewTimestampArray()}
	return &Series{
		typ:  typeTimestampMicros,
		col:  b.column.Name,
		read: metadata.readTimestampMicros,
		meta: metadata,
	}
}

var _ seriesBuilderTimestampMicros = (*arrowSeriesBuilderTimestampMicros)(nil)

func newArrowSeriesFromSliceTimestampMicros(col ColumnName, values []TimestampMicros, mask []bool) *Series {
	builder := newArrowSeriesBuilderTimestampMicros(col)
	builder.Reserve(len(values))

	for i := range values {
		builder.AppendTimestampMicros(values[i], mask == nil || mask[i])
	}

	return builder.Build()
}

func (m *arrowSeriesMeta) readTimestampMicros(_ *seriesIterCache) iterator {
	return &arrowSeriesIterTimestampMicros{
		values: m.values.(*array.Timestamp),
		pos:    -1,
	}
}

type arrowSeriesIterTimestampMicros struct {
	values *array.Timestamp
	pos    int
}

func (i *arrowSeriesIterTimestampMicros) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *arrowSeriesIterTimestampMicros) TimestampMicros() (TimestampMicros, bool) {
	if !i.values.IsNull(i.pos) {
		return TimestampMicros(i.values.Value(i.pos)), true
	} else {
		return TimestampMicros(0), false
	}
}

func (i *arrowSeriesIterTimestampMicros) Value() interface{} {
	if val, ok := i.TimestampMicros(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*arrowSeriesIterTimestampMicros)(nil)
var _ iterTimestampMicros = (*arrowSeriesIterTimestampMicros)(nil)
