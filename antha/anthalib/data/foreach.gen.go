package data

// Code generated by gen.py. DO NOT EDIT.

import "github.com/pkg/errors"

// float64

// Float64 invokes a user-supplied function passing the named column values as float64 arguments.
// An error is returned and execution is aborted at the first null value encountered.
// If given any SchemaAssertions, they are called in the beginning and may have side effects.
func (o *ForeachOn) Float64(fn func(...float64), assertions ...SchemaAssertion) error {
	// schema checks
	if err := o.checkSchema(typeFloat64, assertions...); err != nil {
		return errors.Wrapf(err, "can't iterate over %+v", o.t)
	}

	// iterating over the projected table
	projected := o.t.Must().Project(o.cols...)
	iter := projected.read(projected.series)
	row := make([]float64, len(o.cols))
	rowCounter := 0
	for iter.Next() {
		raw := iter.rawValue()
		for i, val := range raw {
			if val == nil {
				return errors.Errorf("Foreach<float64>: a null value is encountered in column %s, row %d", o.cols[i], rowCounter)
			}
			row[i] = val.(float64)
		}
		fn(row...)
		rowCounter++
	}

	return nil
}

// Float64 invokes a user-supplied function passing the named column values as float64 arguments.
// If a null value is encountered, the function fails.
// If given any SchemaAssertions, they are called in the beginning and may have side effects.
func (on *MustForeachOn) Float64(fn func(...float64), assertions ...SchemaAssertion) {
	err := on.on.Float64(fn, assertions...)
	handle(err)
}

// int64

// Int64 invokes a user-supplied function passing the named column values as int64 arguments.
// An error is returned and execution is aborted at the first null value encountered.
// If given any SchemaAssertions, they are called in the beginning and may have side effects.
func (o *ForeachOn) Int64(fn func(...int64), assertions ...SchemaAssertion) error {
	// schema checks
	if err := o.checkSchema(typeInt64, assertions...); err != nil {
		return errors.Wrapf(err, "can't iterate over %+v", o.t)
	}

	// iterating over the projected table
	projected := o.t.Must().Project(o.cols...)
	iter := projected.read(projected.series)
	row := make([]int64, len(o.cols))
	rowCounter := 0
	for iter.Next() {
		raw := iter.rawValue()
		for i, val := range raw {
			if val == nil {
				return errors.Errorf("Foreach<int64>: a null value is encountered in column %s, row %d", o.cols[i], rowCounter)
			}
			row[i] = val.(int64)
		}
		fn(row...)
		rowCounter++
	}

	return nil
}

// Int64 invokes a user-supplied function passing the named column values as int64 arguments.
// If a null value is encountered, the function fails.
// If given any SchemaAssertions, they are called in the beginning and may have side effects.
func (on *MustForeachOn) Int64(fn func(...int64), assertions ...SchemaAssertion) {
	err := on.on.Int64(fn, assertions...)
	handle(err)
}

// int

// Int invokes a user-supplied function passing the named column values as int arguments.
// An error is returned and execution is aborted at the first null value encountered.
// If given any SchemaAssertions, they are called in the beginning and may have side effects.
func (o *ForeachOn) Int(fn func(...int), assertions ...SchemaAssertion) error {
	// schema checks
	if err := o.checkSchema(typeInt, assertions...); err != nil {
		return errors.Wrapf(err, "can't iterate over %+v", o.t)
	}

	// iterating over the projected table
	projected := o.t.Must().Project(o.cols...)
	iter := projected.read(projected.series)
	row := make([]int, len(o.cols))
	rowCounter := 0
	for iter.Next() {
		raw := iter.rawValue()
		for i, val := range raw {
			if val == nil {
				return errors.Errorf("Foreach<int>: a null value is encountered in column %s, row %d", o.cols[i], rowCounter)
			}
			row[i] = val.(int)
		}
		fn(row...)
		rowCounter++
	}

	return nil
}

// Int invokes a user-supplied function passing the named column values as int arguments.
// If a null value is encountered, the function fails.
// If given any SchemaAssertions, they are called in the beginning and may have side effects.
func (on *MustForeachOn) Int(fn func(...int), assertions ...SchemaAssertion) {
	err := on.on.Int(fn, assertions...)
	handle(err)
}

// string

// String invokes a user-supplied function passing the named column values as string arguments.
// An error is returned and execution is aborted at the first null value encountered.
// If given any SchemaAssertions, they are called in the beginning and may have side effects.
func (o *ForeachOn) String(fn func(...string), assertions ...SchemaAssertion) error {
	// schema checks
	if err := o.checkSchema(typeString, assertions...); err != nil {
		return errors.Wrapf(err, "can't iterate over %+v", o.t)
	}

	// iterating over the projected table
	projected := o.t.Must().Project(o.cols...)
	iter := projected.read(projected.series)
	row := make([]string, len(o.cols))
	rowCounter := 0
	for iter.Next() {
		raw := iter.rawValue()
		for i, val := range raw {
			if val == nil {
				return errors.Errorf("Foreach<string>: a null value is encountered in column %s, row %d", o.cols[i], rowCounter)
			}
			row[i] = val.(string)
		}
		fn(row...)
		rowCounter++
	}

	return nil
}

// String invokes a user-supplied function passing the named column values as string arguments.
// If a null value is encountered, the function fails.
// If given any SchemaAssertions, they are called in the beginning and may have side effects.
func (on *MustForeachOn) String(fn func(...string), assertions ...SchemaAssertion) {
	err := on.on.String(fn, assertions...)
	handle(err)
}

// bool

// Bool invokes a user-supplied function passing the named column values as bool arguments.
// An error is returned and execution is aborted at the first null value encountered.
// If given any SchemaAssertions, they are called in the beginning and may have side effects.
func (o *ForeachOn) Bool(fn func(...bool), assertions ...SchemaAssertion) error {
	// schema checks
	if err := o.checkSchema(typeBool, assertions...); err != nil {
		return errors.Wrapf(err, "can't iterate over %+v", o.t)
	}

	// iterating over the projected table
	projected := o.t.Must().Project(o.cols...)
	iter := projected.read(projected.series)
	row := make([]bool, len(o.cols))
	rowCounter := 0
	for iter.Next() {
		raw := iter.rawValue()
		for i, val := range raw {
			if val == nil {
				return errors.Errorf("Foreach<bool>: a null value is encountered in column %s, row %d", o.cols[i], rowCounter)
			}
			row[i] = val.(bool)
		}
		fn(row...)
		rowCounter++
	}

	return nil
}

// Bool invokes a user-supplied function passing the named column values as bool arguments.
// If a null value is encountered, the function fails.
// If given any SchemaAssertions, they are called in the beginning and may have side effects.
func (on *MustForeachOn) Bool(fn func(...bool), assertions ...SchemaAssertion) {
	err := on.on.Bool(fn, assertions...)
	handle(err)
}

// TimestampMillis

// TimestampMillis invokes a user-supplied function passing the named column values as TimestampMillis arguments.
// An error is returned and execution is aborted at the first null value encountered.
// If given any SchemaAssertions, they are called in the beginning and may have side effects.
func (o *ForeachOn) TimestampMillis(fn func(...TimestampMillis), assertions ...SchemaAssertion) error {
	// schema checks
	if err := o.checkSchema(typeTimestampMillis, assertions...); err != nil {
		return errors.Wrapf(err, "can't iterate over %+v", o.t)
	}

	// iterating over the projected table
	projected := o.t.Must().Project(o.cols...)
	iter := projected.read(projected.series)
	row := make([]TimestampMillis, len(o.cols))
	rowCounter := 0
	for iter.Next() {
		raw := iter.rawValue()
		for i, val := range raw {
			if val == nil {
				return errors.Errorf("Foreach<TimestampMillis>: a null value is encountered in column %s, row %d", o.cols[i], rowCounter)
			}
			row[i] = val.(TimestampMillis)
		}
		fn(row...)
		rowCounter++
	}

	return nil
}

// TimestampMillis invokes a user-supplied function passing the named column values as TimestampMillis arguments.
// If a null value is encountered, the function fails.
// If given any SchemaAssertions, they are called in the beginning and may have side effects.
func (on *MustForeachOn) TimestampMillis(fn func(...TimestampMillis), assertions ...SchemaAssertion) {
	err := on.on.TimestampMillis(fn, assertions...)
	handle(err)
}

// TimestampMicros

// TimestampMicros invokes a user-supplied function passing the named column values as TimestampMicros arguments.
// An error is returned and execution is aborted at the first null value encountered.
// If given any SchemaAssertions, they are called in the beginning and may have side effects.
func (o *ForeachOn) TimestampMicros(fn func(...TimestampMicros), assertions ...SchemaAssertion) error {
	// schema checks
	if err := o.checkSchema(typeTimestampMicros, assertions...); err != nil {
		return errors.Wrapf(err, "can't iterate over %+v", o.t)
	}

	// iterating over the projected table
	projected := o.t.Must().Project(o.cols...)
	iter := projected.read(projected.series)
	row := make([]TimestampMicros, len(o.cols))
	rowCounter := 0
	for iter.Next() {
		raw := iter.rawValue()
		for i, val := range raw {
			if val == nil {
				return errors.Errorf("Foreach<TimestampMicros>: a null value is encountered in column %s, row %d", o.cols[i], rowCounter)
			}
			row[i] = val.(TimestampMicros)
		}
		fn(row...)
		rowCounter++
	}

	return nil
}

// TimestampMicros invokes a user-supplied function passing the named column values as TimestampMicros arguments.
// If a null value is encountered, the function fails.
// If given any SchemaAssertions, they are called in the beginning and may have side effects.
func (on *MustForeachOn) TimestampMicros(fn func(...TimestampMicros), assertions ...SchemaAssertion) {
	err := on.on.TimestampMicros(fn, assertions...)
	handle(err)
}
