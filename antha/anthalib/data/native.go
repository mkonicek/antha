package data

import (
	"reflect"

	"github.com/pkg/errors"
)

// Data sets using go native types.
// Most of the code is autogenerated and lives in native.gen.go

// newNativeSeriesFromSlice converts a slice of scalars to a new native Series.
// Supports both known types (with specializations => fast) and other types (reflectively => slowly).
// notNull == nil implies that all values are not null.
func newNativeSeriesFromSlice(col ColumnName, values interface{}, notNull []bool) (*Series, error) {
	rValue := reflect.ValueOf(values)
	if rValue.Kind() != reflect.Slice {
		return nil, errors.Errorf("can't use input of type %v, expecting slice", rValue.Kind())
	}

	notNull, err := makeNotNullMask(rValue.Len(), notNull)
	if err != nil {
		return nil, err
	}

	m := &nativeSeriesMeta{
		rValue:  rValue,
		notNull: notNull,
	}

	return &Series{
		typ:  rValue.Type().Elem(),
		col:  col,
		read: m.read,
		meta: m,
	}, nil
}

func mustNewNativeSeriesFromSlice(col ColumnName, values interface{}, notNull []bool) *Series {
	series, err := newNativeSeriesFromSlice(col, values, notNull)
	handle(err)
	return series
}

// native series metadata (used for both typed and generic native series)
type nativeSeriesMeta struct {
	rValue  reflect.Value
	notNull []bool
}

func (m *nativeSeriesMeta) IsMaterialized() bool { return true }
func (m *nativeSeriesMeta) ExactSize() int       { return m.len() }
func (m *nativeSeriesMeta) MaxSize() int         { return m.len() }

// return the slice length
func (m *nativeSeriesMeta) len() int {
	return len(m.notNull)
}

// a generic (but slow) native series iterator generator
func (m *nativeSeriesMeta) fallbackRead(_ *seriesIterCache) iterator {
	return &nativeSliceSerIter{
		nativeSeriesMeta: m,
		pos:              -1,
	}
}

var _ boundedMeta = (*nativeSeriesMeta)(nil)

// a generic (but slow) native series iterator
type nativeSliceSerIter struct {
	*nativeSeriesMeta
	pos int
}

func (i *nativeSliceSerIter) Next() bool {
	i.pos++
	return i.pos < i.len()
}

// index into the slice reflectively (slow)
func (i *nativeSliceSerIter) Value() interface{} {
	if !i.notNull[i.pos] {
		return nil
	}
	return i.rValue.Index(i.pos).Interface()
}

// makes a correct nullability mask from the one supplied by user
func makeNotNullMask(length int, notNull []bool) ([]bool, error) {
	if notNull != nil {
		// if the mask we are given is not null, then just checking if its size is correct
		if len(notNull) != length {
			return nil, errors.Errorf("unexpected nulls mask length: expecting %d, given %d", length, len(notNull))
		}
	} else {
		// if the mask we are given is null, then creating a full mask
		notNull = make([]bool, length)
		for i := range notNull {
			notNull[i] = true
		}
	}
	return notNull, nil
}

// fallbackNativeSeriesBuilder implements a generic (but slow) series builder using a reflected slice
type fallbackNativeSeriesBuilder struct {
	column   Column
	slicePtr reflect.Value // *[]valueType
	notNull  []bool
}

func newFallbackNativeSeriesBuilder(col ColumnName, typ reflect.Type) *fallbackNativeSeriesBuilder {
	return &fallbackNativeSeriesBuilder{
		column: Column{
			Name: col,
			Type: typ,
		},
		slicePtr: makeReflectiveSlicePtr(typ, 0, 0),
		notNull:  []bool{},
	}
}

func makeReflectiveSlicePtr(typ reflect.Type, length int, capacity int) reflect.Value {
	slice := reflect.MakeSlice(reflect.SliceOf(typ), length, capacity)
	slicePtr := reflect.New(slice.Type())
	slicePtr.Elem().Set(slice)
	return slicePtr
}

func (f *fallbackNativeSeriesBuilder) Column() Column {
	return f.column
}

func (f *fallbackNativeSeriesBuilder) Reserve(capacity int) {
	slice := f.slicePtr.Elem()
	if capacity > slice.Cap() {
		size := f.Size()

		slicePtr := makeReflectiveSlicePtr(f.column.Type, size, capacity)
		reflect.Copy(slicePtr.Elem(), slice)
		f.slicePtr = slicePtr

		notNull := make([]bool, size, capacity)
		copy(notNull, f.notNull)
		f.notNull = notNull
	}
}

func (f *fallbackNativeSeriesBuilder) Size() int {
	return f.slicePtr.Elem().Len()
}

func (f *fallbackNativeSeriesBuilder) Append(value interface{}) {
	if value != nil {
		f.slicePtr.Elem().Set(reflect.Append(f.slicePtr.Elem(), reflect.ValueOf(value)))
		f.notNull = append(f.notNull, true)
	} else {
		f.slicePtr.Elem().Set(reflect.Append(f.slicePtr.Elem(), reflect.Zero(f.column.Type)))
		f.notNull = append(f.notNull, false)
	}
}

func (f *fallbackNativeSeriesBuilder) Build() *Series {
	return mustNewNativeSeriesFromSlice(f.column.Name, f.slicePtr.Elem().Interface(), f.notNull)
}
