package data

import (
	"reflect"

	"github.com/pkg/errors"
	"github.com/willf/bitset"
)

// Data sets using go native types.
// Most of the code is autogenerated and lives in native.gen.go

// newNativeSeriesFromSlice converts a slice of scalars to a new native Series.
// Supports both known types (with specializations => fast) and other types (reflectively => slowly).
// notNull == nil implies that all values are not null.
func newNativeSeriesFromSlice(col ColumnName, values interface{}, notNull []bool) (*Series, error) {
	rValue := reflect.ValueOf(values)
	if rValue.Kind() != reflect.Slice {
		return nil, errors.Errorf("can't use input of type %v, expecting slice", rValue.Kind())
	}

	notNullBits, err := newNotNullMask(rValue.Len(), notNull)
	if err != nil {
		return nil, err
	}

	m := &nativeSeriesMeta{
		rValue:  rValue,
		len:     rValue.Len(),
		notNull: notNullBits,
	}

	return &Series{
		typ:  rValue.Type().Elem(),
		col:  col,
		read: m.read,
		meta: m,
	}, nil
}

func mustNewNativeSeriesFromSlice(col ColumnName, values interface{}, notNull []bool) *Series {
	series, err := newNativeSeriesFromSlice(col, values, notNull)
	handle(err)
	return series
}

// native series metadata (used for both typed and generic native series)
type nativeSeriesMeta struct {
	rValue  reflect.Value
	len     int
	notNull notNullMask
}

func (m *nativeSeriesMeta) IsMaterialized() bool { return true }
func (m *nativeSeriesMeta) ExactSize() int       { return m.len }
func (m *nativeSeriesMeta) MaxSize() int         { return m.len }

// a generic (but slow) native series iterator generator
func (m *nativeSeriesMeta) fallbackRead(_ *seriesIterCache) iterator {
	return &nativeSliceSerIter{
		nativeSeriesMeta: m,
		pos:              -1,
	}
}

var _ boundedMeta = (*nativeSeriesMeta)(nil)

// a generic (but slow) native series iterator
type nativeSliceSerIter struct {
	*nativeSeriesMeta
	pos int
}

func (i *nativeSliceSerIter) Next() bool {
	i.pos++
	return i.pos < i.len
}

// index into the slice reflectively (slow)
func (i *nativeSliceSerIter) Value() interface{} {
	if !i.notNull.Test(i.pos) {
		return nil
	}
	return i.rValue.Index(i.pos).Interface()
}

// notNullMask is a bitset exposing non-null values of a slice series
type notNullMask struct {
	bitset.BitSet
}

func newNotNullMask(length int, notNull []bool) (notNullMask, error) {
	if notNull == nil {
		// nil mask is considered a full mask
		return notNullMask{*bitset.New(uint(length)).Complement()}, nil
	}
	if len(notNull) != length {
		return notNullMask{}, errors.Errorf("unexpected nulls mask length: expecting %d, given %d", length, len(notNull))
	}
	mask := notNullMask{*bitset.New(uint(length))}
	for i, bit := range notNull {
		mask.SetTo(i, bit)
	}
	return mask, nil
}

func (m *notNullMask) Set(index int) {
	m.BitSet.Set(uint(index))
}

func (m *notNullMask) Clear(index int) {
	m.BitSet.Clear(uint(index))
}

func (m *notNullMask) SetTo(index int, bit bool) {
	m.BitSet.SetTo(uint(index), bit)
}

func (m *notNullMask) Test(index int) bool {
	return m.BitSet.Test(uint(index))
}

func (m *notNullMask) Swap(i, j int) {
	tmp := m.Test(i)
	m.SetTo(i, m.Test(j))
	m.SetTo(j, tmp)
}

// fallbackNativeSeriesBuilder implements a generic (but slow) series builder using a reflected slice
type fallbackNativeSeriesBuilder struct {
	column   Column
	slicePtr reflect.Value // *[]valueType
	notNull  []bool
}

func newFallbackNativeSeriesBuilder(col ColumnName, typ reflect.Type) *fallbackNativeSeriesBuilder {
	return &fallbackNativeSeriesBuilder{
		column: Column{
			Name: col,
			Type: typ,
		},
		slicePtr: makeReflectiveSlicePtr(typ, 0, 0),
		notNull:  []bool{},
	}
}

func makeReflectiveSlicePtr(typ reflect.Type, length int, capacity int) reflect.Value {
	slice := reflect.MakeSlice(reflect.SliceOf(typ), length, capacity)
	slicePtr := reflect.New(slice.Type())
	slicePtr.Elem().Set(slice)
	return slicePtr
}

func (f *fallbackNativeSeriesBuilder) Column() Column {
	return f.column
}

func (f *fallbackNativeSeriesBuilder) Reserve(capacity int) {
	slice := f.slicePtr.Elem()
	if capacity > slice.Cap() {
		size := f.Size()

		slicePtr := makeReflectiveSlicePtr(f.column.Type, size, capacity)
		reflect.Copy(slicePtr.Elem(), slice)
		f.slicePtr = slicePtr

		notNull := make([]bool, size, capacity)
		copy(notNull, f.notNull)
		f.notNull = notNull
	}
}

func (f *fallbackNativeSeriesBuilder) Size() int {
	return f.slicePtr.Elem().Len()
}

func (f *fallbackNativeSeriesBuilder) Append(value interface{}) {
	if value != nil {
		f.slicePtr.Elem().Set(reflect.Append(f.slicePtr.Elem(), reflect.ValueOf(value)))
		f.notNull = append(f.notNull, true)
	} else {
		f.slicePtr.Elem().Set(reflect.Append(f.slicePtr.Elem(), reflect.Zero(f.column.Type)))
		f.notNull = append(f.notNull, false)
	}
}

func (f *fallbackNativeSeriesBuilder) Build() *Series {
	return mustNewNativeSeriesFromSlice(f.column.Name, f.slicePtr.Elem().Interface(), f.notNull)
}
