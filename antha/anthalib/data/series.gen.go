package data

// Code generated by gen.py. DO NOT EDIT.

/*
 * 'iter<Type'> are iterator specializations for potentially no-copy, boxed values.
 *
 * The 'as<Type>' types are fallbacks for when the underlying series is dynamic.
 */

// boxFloat64 represents a nullable float64 value
type boxFloat64 interface {
	Float64() (float64, bool) // returns false = nil
}

// iterFloat64 iterates over nullable float64 values
type iterFloat64 interface {
	advanceable
	boxFloat64
}

// iterateFloat64 is a fallback to convert dynamic series to static iterator type.
// an error is returned if the series' declared type is not assignable to float64
func (s *Series) iterateFloat64(iter iterator) (iterFloat64, error) {
	if cast, ok := iter.(iterFloat64); ok {
		return cast, nil
	}
	if err := s.assignableTo(typeFloat64); err != nil {
		return nil, err
	}
	return &asFloat64{iterator: iter}, nil
}

type asFloat64 struct {
	iterator
}

func (a *asFloat64) Float64() (float64, bool) {
	v := a.iterator.Value()
	if v == nil {
		return float64(0), false
	}
	return v.(float64), true
}

// boxInt64 represents a nullable int64 value
type boxInt64 interface {
	Int64() (int64, bool) // returns false = nil
}

// iterInt64 iterates over nullable int64 values
type iterInt64 interface {
	advanceable
	boxInt64
}

// iterateInt64 is a fallback to convert dynamic series to static iterator type.
// an error is returned if the series' declared type is not assignable to int64
func (s *Series) iterateInt64(iter iterator) (iterInt64, error) {
	if cast, ok := iter.(iterInt64); ok {
		return cast, nil
	}
	if err := s.assignableTo(typeInt64); err != nil {
		return nil, err
	}
	return &asInt64{iterator: iter}, nil
}

type asInt64 struct {
	iterator
}

func (a *asInt64) Int64() (int64, bool) {
	v := a.iterator.Value()
	if v == nil {
		return int64(0), false
	}
	return v.(int64), true
}

// boxInt represents a nullable int value
type boxInt interface {
	Int() (int, bool) // returns false = nil
}

// iterInt iterates over nullable int values
type iterInt interface {
	advanceable
	boxInt
}

// iterateInt is a fallback to convert dynamic series to static iterator type.
// an error is returned if the series' declared type is not assignable to int
func (s *Series) iterateInt(iter iterator) (iterInt, error) {
	if cast, ok := iter.(iterInt); ok {
		return cast, nil
	}
	if err := s.assignableTo(typeInt); err != nil {
		return nil, err
	}
	return &asInt{iterator: iter}, nil
}

type asInt struct {
	iterator
}

func (a *asInt) Int() (int, bool) {
	v := a.iterator.Value()
	if v == nil {
		return 0, false
	}
	return v.(int), true
}

// boxString represents a nullable string value
type boxString interface {
	String() (string, bool) // returns false = nil
}

// iterString iterates over nullable string values
type iterString interface {
	advanceable
	boxString
}

// iterateString is a fallback to convert dynamic series to static iterator type.
// an error is returned if the series' declared type is not assignable to string
func (s *Series) iterateString(iter iterator) (iterString, error) {
	if cast, ok := iter.(iterString); ok {
		return cast, nil
	}
	if err := s.assignableTo(typeString); err != nil {
		return nil, err
	}
	return &asString{iterator: iter}, nil
}

type asString struct {
	iterator
}

func (a *asString) String() (string, bool) {
	v := a.iterator.Value()
	if v == nil {
		return "", false
	}
	return v.(string), true
}

// boxBool represents a nullable bool value
type boxBool interface {
	Bool() (bool, bool) // returns false = nil
}

// iterBool iterates over nullable bool values
type iterBool interface {
	advanceable
	boxBool
}

// iterateBool is a fallback to convert dynamic series to static iterator type.
// an error is returned if the series' declared type is not assignable to bool
func (s *Series) iterateBool(iter iterator) (iterBool, error) {
	if cast, ok := iter.(iterBool); ok {
		return cast, nil
	}
	if err := s.assignableTo(typeBool); err != nil {
		return nil, err
	}
	return &asBool{iterator: iter}, nil
}

type asBool struct {
	iterator
}

func (a *asBool) Bool() (bool, bool) {
	v := a.iterator.Value()
	if v == nil {
		return false, false
	}
	return v.(bool), true
}

// boxTimestampMillis represents a nullable TimestampMillis value
type boxTimestampMillis interface {
	TimestampMillis() (TimestampMillis, bool) // returns false = nil
}

// iterTimestampMillis iterates over nullable TimestampMillis values
type iterTimestampMillis interface {
	advanceable
	boxTimestampMillis
}

// iterateTimestampMillis is a fallback to convert dynamic series to static iterator type.
// an error is returned if the series' declared type is not assignable to TimestampMillis
func (s *Series) iterateTimestampMillis(iter iterator) (iterTimestampMillis, error) {
	if cast, ok := iter.(iterTimestampMillis); ok {
		return cast, nil
	}
	if err := s.assignableTo(typeTimestampMillis); err != nil {
		return nil, err
	}
	return &asTimestampMillis{iterator: iter}, nil
}

type asTimestampMillis struct {
	iterator
}

func (a *asTimestampMillis) TimestampMillis() (TimestampMillis, bool) {
	v := a.iterator.Value()
	if v == nil {
		return TimestampMillis(0), false
	}
	return v.(TimestampMillis), true
}

// boxTimestampMicros represents a nullable TimestampMicros value
type boxTimestampMicros interface {
	TimestampMicros() (TimestampMicros, bool) // returns false = nil
}

// iterTimestampMicros iterates over nullable TimestampMicros values
type iterTimestampMicros interface {
	advanceable
	boxTimestampMicros
}

// iterateTimestampMicros is a fallback to convert dynamic series to static iterator type.
// an error is returned if the series' declared type is not assignable to TimestampMicros
func (s *Series) iterateTimestampMicros(iter iterator) (iterTimestampMicros, error) {
	if cast, ok := iter.(iterTimestampMicros); ok {
		return cast, nil
	}
	if err := s.assignableTo(typeTimestampMicros); err != nil {
		return nil, err
	}
	return &asTimestampMicros{iterator: iter}, nil
}

type asTimestampMicros struct {
	iterator
}

func (a *asTimestampMicros) TimestampMicros() (TimestampMicros, bool) {
	v := a.iterator.Value()
	if v == nil {
		return TimestampMicros(0), false
	}
	return v.(TimestampMicros), true
}
