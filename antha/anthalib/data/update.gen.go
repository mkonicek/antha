package data

// Code generated by gen.py. DO NOT EDIT.

import (
	"reflect"
)

// Float64 updates a float64 col using float64 inputs.  Null on any null inputs.
// Returns error if any column cannot be assigned to float64; no conversions are performed.
func (on *UpdateOn) Float64(fn func(v ...float64) (float64, bool)) (*Table, error) {
	return on.us.updateByExtend(func(t *Table, colName ColumnName, colType reflect.Type) (*Table, error) {
		// extending on columns of type float64 by a column of type float64
		return t.Extend(colName).On(on.inputCols...).Float64(fn)
	})
}

// InterfaceFloat64 updates a float64 col using interface{} inputs.
func (on *UpdateOn) InterfaceFloat64(fn func(v ...interface{}) (float64, bool)) (*Table, error) {
	return on.us.updateByExtend(func(t *Table, colName ColumnName, colType reflect.Type) (*Table, error) {
		// extending on columns of type float64 by a column of type float64
		return t.Extend(colName).On(on.inputCols...).InterfaceFloat64(fn)
	})
}

// Float64 updates a float64 col using float64 inputs.  Null on any null inputs.
// Returns error if any column cannot be assigned to float64; no conversions are performed.
func (on *MustUpdateOn) Float64(fn func(v ...float64) (float64, bool)) *Table {
	t, err := on.UpdateOn.Float64(fn)
	handle(err)
	return t
}

// InterfaceFloat64 updates a float64 col using interface{} inputs.
func (on *MustUpdateOn) InterfaceFloat64(fn func(v ...interface{}) (float64, bool)) *Table {
	t, err := on.UpdateOn.InterfaceFloat64(fn)
	handle(err)
	return t
}

// Int64 updates a int64 col using int64 inputs.  Null on any null inputs.
// Returns error if any column cannot be assigned to int64; no conversions are performed.
func (on *UpdateOn) Int64(fn func(v ...int64) (int64, bool)) (*Table, error) {
	return on.us.updateByExtend(func(t *Table, colName ColumnName, colType reflect.Type) (*Table, error) {
		// extending on columns of type int64 by a column of type int64
		return t.Extend(colName).On(on.inputCols...).Int64(fn)
	})
}

// InterfaceInt64 updates a int64 col using interface{} inputs.
func (on *UpdateOn) InterfaceInt64(fn func(v ...interface{}) (int64, bool)) (*Table, error) {
	return on.us.updateByExtend(func(t *Table, colName ColumnName, colType reflect.Type) (*Table, error) {
		// extending on columns of type int64 by a column of type int64
		return t.Extend(colName).On(on.inputCols...).InterfaceInt64(fn)
	})
}

// Int64 updates a int64 col using int64 inputs.  Null on any null inputs.
// Returns error if any column cannot be assigned to int64; no conversions are performed.
func (on *MustUpdateOn) Int64(fn func(v ...int64) (int64, bool)) *Table {
	t, err := on.UpdateOn.Int64(fn)
	handle(err)
	return t
}

// InterfaceInt64 updates a int64 col using interface{} inputs.
func (on *MustUpdateOn) InterfaceInt64(fn func(v ...interface{}) (int64, bool)) *Table {
	t, err := on.UpdateOn.InterfaceInt64(fn)
	handle(err)
	return t
}

// Int updates a int col using int inputs.  Null on any null inputs.
// Returns error if any column cannot be assigned to int; no conversions are performed.
func (on *UpdateOn) Int(fn func(v ...int) (int, bool)) (*Table, error) {
	return on.us.updateByExtend(func(t *Table, colName ColumnName, colType reflect.Type) (*Table, error) {
		// extending on columns of type int by a column of type int
		return t.Extend(colName).On(on.inputCols...).Int(fn)
	})
}

// InterfaceInt updates a int col using interface{} inputs.
func (on *UpdateOn) InterfaceInt(fn func(v ...interface{}) (int, bool)) (*Table, error) {
	return on.us.updateByExtend(func(t *Table, colName ColumnName, colType reflect.Type) (*Table, error) {
		// extending on columns of type int by a column of type int
		return t.Extend(colName).On(on.inputCols...).InterfaceInt(fn)
	})
}

// Int updates a int col using int inputs.  Null on any null inputs.
// Returns error if any column cannot be assigned to int; no conversions are performed.
func (on *MustUpdateOn) Int(fn func(v ...int) (int, bool)) *Table {
	t, err := on.UpdateOn.Int(fn)
	handle(err)
	return t
}

// InterfaceInt updates a int col using interface{} inputs.
func (on *MustUpdateOn) InterfaceInt(fn func(v ...interface{}) (int, bool)) *Table {
	t, err := on.UpdateOn.InterfaceInt(fn)
	handle(err)
	return t
}

// String updates a string col using string inputs.  Null on any null inputs.
// Returns error if any column cannot be assigned to string; no conversions are performed.
func (on *UpdateOn) String(fn func(v ...string) (string, bool)) (*Table, error) {
	return on.us.updateByExtend(func(t *Table, colName ColumnName, colType reflect.Type) (*Table, error) {
		// extending on columns of type string by a column of type string
		return t.Extend(colName).On(on.inputCols...).String(fn)
	})
}

// InterfaceString updates a string col using interface{} inputs.
func (on *UpdateOn) InterfaceString(fn func(v ...interface{}) (string, bool)) (*Table, error) {
	return on.us.updateByExtend(func(t *Table, colName ColumnName, colType reflect.Type) (*Table, error) {
		// extending on columns of type string by a column of type string
		return t.Extend(colName).On(on.inputCols...).InterfaceString(fn)
	})
}

// String updates a string col using string inputs.  Null on any null inputs.
// Returns error if any column cannot be assigned to string; no conversions are performed.
func (on *MustUpdateOn) String(fn func(v ...string) (string, bool)) *Table {
	t, err := on.UpdateOn.String(fn)
	handle(err)
	return t
}

// InterfaceString updates a string col using interface{} inputs.
func (on *MustUpdateOn) InterfaceString(fn func(v ...interface{}) (string, bool)) *Table {
	t, err := on.UpdateOn.InterfaceString(fn)
	handle(err)
	return t
}

// Bool updates a bool col using bool inputs.  Null on any null inputs.
// Returns error if any column cannot be assigned to bool; no conversions are performed.
func (on *UpdateOn) Bool(fn func(v ...bool) (bool, bool)) (*Table, error) {
	return on.us.updateByExtend(func(t *Table, colName ColumnName, colType reflect.Type) (*Table, error) {
		// extending on columns of type bool by a column of type bool
		return t.Extend(colName).On(on.inputCols...).Bool(fn)
	})
}

// InterfaceBool updates a bool col using interface{} inputs.
func (on *UpdateOn) InterfaceBool(fn func(v ...interface{}) (bool, bool)) (*Table, error) {
	return on.us.updateByExtend(func(t *Table, colName ColumnName, colType reflect.Type) (*Table, error) {
		// extending on columns of type bool by a column of type bool
		return t.Extend(colName).On(on.inputCols...).InterfaceBool(fn)
	})
}

// Bool updates a bool col using bool inputs.  Null on any null inputs.
// Returns error if any column cannot be assigned to bool; no conversions are performed.
func (on *MustUpdateOn) Bool(fn func(v ...bool) (bool, bool)) *Table {
	t, err := on.UpdateOn.Bool(fn)
	handle(err)
	return t
}

// InterfaceBool updates a bool col using interface{} inputs.
func (on *MustUpdateOn) InterfaceBool(fn func(v ...interface{}) (bool, bool)) *Table {
	t, err := on.UpdateOn.InterfaceBool(fn)
	handle(err)
	return t
}

// TimestampMillis updates a TimestampMillis col using TimestampMillis inputs.  Null on any null inputs.
// Returns error if any column cannot be assigned to TimestampMillis; no conversions are performed.
func (on *UpdateOn) TimestampMillis(fn func(v ...TimestampMillis) (TimestampMillis, bool)) (*Table, error) {
	return on.us.updateByExtend(func(t *Table, colName ColumnName, colType reflect.Type) (*Table, error) {
		// extending on columns of type TimestampMillis by a column of type TimestampMillis
		return t.Extend(colName).On(on.inputCols...).TimestampMillis(fn)
	})
}

// InterfaceTimestampMillis updates a TimestampMillis col using interface{} inputs.
func (on *UpdateOn) InterfaceTimestampMillis(fn func(v ...interface{}) (TimestampMillis, bool)) (*Table, error) {
	return on.us.updateByExtend(func(t *Table, colName ColumnName, colType reflect.Type) (*Table, error) {
		// extending on columns of type TimestampMillis by a column of type TimestampMillis
		return t.Extend(colName).On(on.inputCols...).InterfaceTimestampMillis(fn)
	})
}

// TimestampMillis updates a TimestampMillis col using TimestampMillis inputs.  Null on any null inputs.
// Returns error if any column cannot be assigned to TimestampMillis; no conversions are performed.
func (on *MustUpdateOn) TimestampMillis(fn func(v ...TimestampMillis) (TimestampMillis, bool)) *Table {
	t, err := on.UpdateOn.TimestampMillis(fn)
	handle(err)
	return t
}

// InterfaceTimestampMillis updates a TimestampMillis col using interface{} inputs.
func (on *MustUpdateOn) InterfaceTimestampMillis(fn func(v ...interface{}) (TimestampMillis, bool)) *Table {
	t, err := on.UpdateOn.InterfaceTimestampMillis(fn)
	handle(err)
	return t
}

// TimestampMicros updates a TimestampMicros col using TimestampMicros inputs.  Null on any null inputs.
// Returns error if any column cannot be assigned to TimestampMicros; no conversions are performed.
func (on *UpdateOn) TimestampMicros(fn func(v ...TimestampMicros) (TimestampMicros, bool)) (*Table, error) {
	return on.us.updateByExtend(func(t *Table, colName ColumnName, colType reflect.Type) (*Table, error) {
		// extending on columns of type TimestampMicros by a column of type TimestampMicros
		return t.Extend(colName).On(on.inputCols...).TimestampMicros(fn)
	})
}

// InterfaceTimestampMicros updates a TimestampMicros col using interface{} inputs.
func (on *UpdateOn) InterfaceTimestampMicros(fn func(v ...interface{}) (TimestampMicros, bool)) (*Table, error) {
	return on.us.updateByExtend(func(t *Table, colName ColumnName, colType reflect.Type) (*Table, error) {
		// extending on columns of type TimestampMicros by a column of type TimestampMicros
		return t.Extend(colName).On(on.inputCols...).InterfaceTimestampMicros(fn)
	})
}

// TimestampMicros updates a TimestampMicros col using TimestampMicros inputs.  Null on any null inputs.
// Returns error if any column cannot be assigned to TimestampMicros; no conversions are performed.
func (on *MustUpdateOn) TimestampMicros(fn func(v ...TimestampMicros) (TimestampMicros, bool)) *Table {
	t, err := on.UpdateOn.TimestampMicros(fn)
	handle(err)
	return t
}

// InterfaceTimestampMicros updates a TimestampMicros col using interface{} inputs.
func (on *MustUpdateOn) InterfaceTimestampMicros(fn func(v ...interface{}) (TimestampMicros, bool)) *Table {
	t, err := on.UpdateOn.InterfaceTimestampMicros(fn)
	handle(err)
	return t
}
